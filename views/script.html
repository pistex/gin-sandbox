$gin{define "script"}
<script src="https://cdn.jsdelivr.net/npm/vue@2.x"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.x"></script>
<script src="https://unpkg.com/vuex@2.x"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdn.omise.co/omise.js"></script>
<script>

    // Omise
    OmiseCard.configure({
        publicKey: "pkey_test_5lr43m5s2v9k5iohgnp"
    })
    // helpers
    function errorResponseAlert(error) {
        if (error.response) {
            const responseStatus = error.response.status
            if (error.response.data.message) {
                alert(error.response.data.message)
            } else if (responseStatus === 400) {
                alert('Invalid data is sent to server. Please try again.')
            } else if (responseStatus === 401) {
                alert('Authorization failed. The authenticated user is not allowed to perform this action or the request is made by anonymous user.')
            } else if (responseStatus === 403) {
                alert('Permission failed. This action is not allowed.')
            } else if (responseStatus === 404) {
                alert('Requested url not found. Please report the issue to admin.')
            } else if (responseStatus === 405) {
                alert('Requested method is not allow. Please report the issue to admin.')
            } else if (responseStatus === 500) {
                alert('Internal server error. Please report the issue to admin.')
            }
        } else {
            alert(error)
            throw new Error(error)
        }
    }

    async function requestHeader() {
        let user = JSON.parse(localStorage.getItem('user'))
        if (user && user.token) {
            try {
                await axios.get('/api/authentication/token/verify', { headers: { 'Authorization': 'Bearer ' + user.token.accessToken } })
                return { 'Authorization': 'Bearer ' + user.token.accessToken }
            } catch {
                try {
                    const response = await axios.post('/api/authentication/token/refresh', { refresh_token: user.token.refreshToken }, { headers: { 'Authorization': 'Bearer ' + user.token.accessToken } })
                    user.token.accessToken = response.data.token['access_token']
                    localStorage.setItem('user', JSON.stringify(user))
                    return { 'Authorization': 'Bearer ' + user.token.accessToken }
                } catch {
                    alert('Authentication token is expired. User has been automatically logout.')
                    localStorage.removeItem('user')
                    window.location = '/'
                    return {}
                }
            }
        } else {
            return {}
        }
    }

    // shared store
    const sharedState = () => ({ allUsernames: [] })
    const sharedGetters = {
        allUsernames(state) {
            return state.allUsernames
        }
    }
    const sharedActions = {
        async fetchUsernames({ commit }) {
            try {
                const response = await axios.get('/api/user/all', { headers: await requestHeader() })
                commit('setUsername', response.data.usernames)
            } catch (error) {
                errorResponseAlert(error)
            }
        }
    }
    const sharedMutations = {
        setUsername(state, usernames) {
            state.allUsernames = usernames
        }
    }

    const shared = {
        namespaced: true,
        state: sharedState,
        getters: sharedGetters,
        mutations: sharedMutations,
        actions: sharedActions,
    }

    // authentication store
    const user = JSON.parse(localStorage.getItem('user'))
    const initialState = user
        ? { loggedIn: true, user }
        : { loggedIn: false, user: null };
    const authenticationState = () => ({ ...initialState })
    const authenticationGetters = {
        getAuthenticationStatus(state) {
            return state.loggedIn
        },
        getUser(state) {
            return state.user
        }
    }
    const authenticationActions = {
        async login({ commit }, { id, password }) {
            try {
                let response = await axios.post('/api/authentication/login/', { id, password })
                let user = {
                    token: {
                        accessToken: response.data.token['access_token'],
                        refreshToken: response.data.token['refresh_token']
                    }
                }
                localStorage.setItem('user', JSON.stringify(user))
                response = await axios.get('/api/user/my_profile', { headers: await requestHeader() })
                user.profile = response.data.profile
                localStorage.setItem('user', JSON.stringify(user))
                commit('loginSuccess', user)
            } catch (error) {
                commit('loginFailed')
                errorResponseAlert(error)
            }
        },
        async logout({ commit, getters }) {
            await axios.post('/api/authentication/logout/', { refresh_token: getters['getUser'].token.refreshToken }, { headers: await requestHeader() })
            localStorage.removeItem('user')
            commit('logout')
            window.location = '/'
        },
        async register({ commit }, { username, email, password }) {
            try {
                let response = await axios.post('/api/authentication/register/', { username, email, password })
                let user = {
                    token: {
                        accessToken: response.data.token['access_token'],
                        refreshToken: response.data.token['refresh_token']
                    }
                }
                localStorage.setItem('user', JSON.stringify(user))
                response = await axios.get('/api/user/my_profile', { headers: await requestHeader() })
                user.profile = response.data.profile
                localStorage.setItem('user', JSON.stringify(user))
                commit('loginSuccess', user)
            } catch (error) {
                errorResponseAlert(error)
            }
        },
        async fecthUserData() {
            try {
                const response = await axios.get('/api/user/my_profile', { headers: await requestHeader() })
                user.profile = response.data.profile
                localStorage.setItem('user', JSON.stringify(user))
            } catch (error) {
                errorResponseAlert(error)
            }
        }
    }
    const authenticationMutations = {
        updateUser(state, user) {
            state.user = user;
        },
        loginSuccess(state, user) {
            state.loggedIn = true;
            state.user = user;
        },
        loginFailed(state) {
            state.loggedIn = false;
            state.user = null;
        },
        logout(state) {
            state.loggedIn = false;
            state.user = null;
        }
    }
    const authentication = {
        namespaced: true,
        state: authenticationState,
        getters: authenticationGetters,
        actions: authenticationActions,
        mutations: authenticationMutations
    }
    // project store
    const projectState = () => ({
        allProjects: [],
        projectsAreFetched: false
    })
    const projectGetters = {
        allProjects(state) {
            return state.allProjects.sort((a, b) => { return new Date(b.created_date) - new Date(a.created_date) })
        },
        projectsAreFetched(state) {
            return state.projectsAreFetched
        },
        addingProject(state) {
            return state.addingProject
        }
    }
    const projectActions = {
        async fetchProjects({ commit }) {
            try {
                const response = await axios.get('/api/project/all/', { headers: await requestHeader() })
                commit('setProjects', response.data.projects)
            } catch (error) {
                errorResponseAlert(error)
            }
        },
        async addProject({ commit, dispatch, rootGetters }, { name }) {
            try {
                const user = rootGetters['authentication/getUser']
                const username = user.profile.username
                commit('addNewProject', { name, user: username, members: [username] })
                dispatch('updateUserProject', { user, action: "add" })
                await axios.post('/api/project/new/', { name }, { headers: await requestHeader() })
                dispatch('fetchProjects')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        async removeProject({ commit, dispatch, rootGetters }, id) {
            try {
                commit('removeProject', id)
                const user = rootGetters['authentication/getUser']
                dispatch('updateUserProject', { user, action: "remove" })
                await axios.delete('/api/project/delete/', { headers: await requestHeader(), data: { id } })
                dispatch('fetchProjects')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        updateProject({ commit, dispatch, rootGetters }, { id, name, members }) {
            const user = rootGetters['authentication/getUser']
            const username = user.profile.username
            const project = { id, name, members, user: username }
            commit('updatedProject', project)
            dispatch('fetchProjects')
        },
        updateUserProject({ getters, commit }, { user, action }) {
            if (action === "add") {
                user.profile.projects = user.profile.projects + 1
            } else {
                user.profile.projects = user.profile.projects - 1
            }
            commit('authentication/updateUser', user, { root: true })
        }
    }

    const projectMutations = {
        setProjects(state, projects) {
            state.allProjects = projects;
            state.projectsAreFetched = true;
        },
        addNewProject(state, { name, user, members }) {
            state.allProjects.unshift({ name, user, members })
        },
        removeProject(state, id) {
            state.allProjects = state.allProjects.filter((element) => { return element.id != id })
        },
        updatedProject(state, project) {
            const index = state.allProjects.findIndex((element) => { return element.id == project.id })
            state.allProjects[index] = { ...project }
        }
    }
    const project = {
        namespaced: true,
        state: projectState,
        getters: projectGetters,
        mutations: projectMutations,
        actions: projectActions,
    }

    // Board store
    const boardState = () => ({
        allBoards: [],
        thisProject: {}
    })

    const boardGetters = {
        allBoards(state) {
            return state.allBoards.sort((a, b) => { return a.position - b.position })
        },
        thisProject(state) {
            return state.thisProject
        }
    }

    const boardActions = {
        async fetchThisProject({ commit }) {
            try {
                const response = await axios.post('/api/project/find', { id: JSON.parse(`$gin{ .projectId }`) }, { headers: await requestHeader() })
                const project = response.data.project
                commit('setThisProject', project)
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        async fetchBoards({ commit }) {
            try {
                const response = await axios.post('/api/board/all', { project: JSON.parse(`$gin{ .projectId }`) }, { headers: await requestHeader() })
                commit('setAllBoards', response.data.boards)
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        async addBoard({ commit, dispatch }, name) {
            try {
                commit('addNewBoard', name)
                const response = await axios.post('/api/board/new', { project: JSON.parse(`$gin{ .projectId }`), name }, { headers: await requestHeader() })
                dispatch('fetchBoards')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        updateBoard({ commit, dispatch }, { id, name, position }) {
            const board = { id, name, position }
            commit('updatedBoard', board)
            dispatch('fetchBoards')
        },
        async removeBoard({ commit, dispatch }, { id }) {
            try {
                commit('removeBoard', id)
                await axios.delete('/api/board/delete', { headers: await requestHeader(), data: { id } })
                dispatch('fetchBoards')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        async moveBoard({ commit, getters, dispatch }, { id, action }) {
            const oldData = getters['allBoards'].find(element => { return element.id == id })
            const oldPosition = oldData.position
            let newPostion
            if (action == 'up') {
                newPosition = oldPosition + 1
            } else {
                newPosition = oldPosition - 1
            }
            try {
                commit('setBoardPosition', { id, newPosition })
            } catch {
                return
            }
            try {
                await axios.patch('/api/board/update', { id, name: oldData.name, position: newPosition }, { headers: await requestHeader() })
                dispatch('fetchBoards')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        }
    }

    const boardMutations = {
        setThisProject(state, project) {
            state.thisProject = project;
        },
        setAllBoards(state, boards) {
            state.allBoards = boards;
        },
        addNewBoard(state, name) {
            const position = state.allBoards.length + 1
            state.allBoards.push({ name, position })
        },
        removeBoard(state, id) {
            const deletedPosition = state.allBoards.find(element => { return element.id == id }).position
            state.allBoards = state.allBoards.filter(element => { return element.id !== id })
            state.allBoards.forEach(element => {
                if (element.position > deletedPosition) {
                    element.position = element.position - 1
                }
            })
        },
        setBoardPosition(state, { id, newPosition }) {
            try {
                state.allBoards.find(element => { return element.position == newPosition }).position = state.allBoards.find(element => { return element.id == id }).position
                state.allBoards.find(element => { return element.id == id }).position = newPosition
            } catch (error) {
                throw new Error(error)
            }
        },
        updatedBoard(state, board) {
            const index = state.allBoards.findIndex((element) => { return element.id == board.id })
            state.allBoards[index] = { ...board }
        }
    }

    const board = {
        namespaced: true,
        state: boardState,
        getters: boardGetters,
        actions: boardActions,
        mutations: boardMutations
    }

    // post
    const postState = () => ({
        allPosts: []
    })

    const postGetters = {
        allPosts(state) {
            return state.allPosts
        }
    }
    const postActions = {
        async fetchPosts({ commit }) {
            try {
                const response = await axios.post('/api/post/all', { project: JSON.parse(`$gin{ .projectId }`) }, { headers: await requestHeader() })
                let posts = response.data.posts
                posts.forEach(post => {
                    if (!post.comments) {
                        post.comments = []
                    }
                    if (!post.people) {
                        post.people = []
                    }
                })
                commit('setPosts', posts)
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        async addPost({ commit, rootGetters, getters, dispatch }, { board, project, title, content, due_date }) {
            const user = rootGetters['authentication/getUser']
            const username = user.profile.username
            const post = {
                id: '',
                board,
                project,
                user: username,
                title,
                content,
                comments: [],
                completed: false,
                urgent: false,
                people: [],
                added_date: new Date().toISOString(),
                last_modified: new Date().toISOString(),
                due_date: new Date(due_date + ' 00:00:00').toISOString()
            }
            commit('addNewPost', post)
            try {
                await axios.post('/api/post/new', post, { headers: await requestHeader() })
                dispatch('fetchPosts')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        updatePost({ commit, dispatch }, post) {
            commit('updatePost', post)
            dispatch('fetchPosts')
        },
        async toggleCompleteStatus({ commit, getters, dispatch }, { id, board }) {
            commit('toggleCompleteStatus', { id, board })
            const post = getters['allPosts'].find(element => { return element.id == id })
            try {
                await axios.patch('/api/post/update', post, { headers: await requestHeader() })
                dispatch('fetchPosts')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        async toggleUrgentStatus({ commit, getters, dispatch }, { id, board }) {
            commit('toggleUrgentStatus', { id, board })
            const post = getters['allPosts'].find(element => { return element.id == id })
            try {
                await axios.patch('/api/post/update', post, { headers: await requestHeader() })
                dispatch('fetchPosts')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        },
        async movePost({ commit, getters, rootGetters, dispatch }, { id, board, action }) {
            const oldBoard = rootGetters['board/allBoards'].find(element => { return element.id == board })
            const oldPosition = oldBoard.position
            let newPosition
            if (action == 'up') {
                newPosition = oldPosition + 1
            } else {
                newPosition = oldPosition - 1
            }
            const newBoard = rootGetters['board/allBoards'].find(element => { return element.position == newPosition })
            try {
                commit('setPostBoard', { id, newBoard })
            } catch {
                return
            }
            const post = getters['allPosts'].find(element => { return element.id == id })
            try {
                await axios.patch('/api/post/update', post, { headers: await requestHeader() })
                dispatch('fetchPosts')
            } catch (error) {
                errorResponseAlert(error)
                location.reload()
            }
        }
    }
    const postMutations = {
        setPosts(state, posts) {
            state.allPosts = posts
        },
        addNewPost(state, post) {
            state.allPosts.push(post)
        },
        updatePost(state, post) {
            const index = state.allPosts.findIndex((element) => { return element.id == post.id })
            state.allPosts[index] = { ...post }
        },
        toggleCompleteStatus(state, { id, board }) {
            state.allPosts.find(element => { return element.id == id }).completed = !state.allPosts.find(element => { return element.id == id }).completed
        },
        toggleUrgentStatus(state, { id, board }) {
            state.allPosts.find(element => { return element.id == id }).urgent = !state.allPosts.find(element => { return element.id == id }).urgent
        },
        setPostBoard(state, { id, newBoard }) {
            state.allPosts.find(element => { return element.id == id }).board = newBoard.id
        }
    }

    const post = {
        namespaced: true,
        state: postState,
        getters: postGetters,
        actions: postActions,
        mutations: postMutations
    }
    new Vue({
        el: '#app',
        store: new Vuex.Store({
            modules: {
                authentication,
                shared,
                project,
                board,
                post
            }
        }),
        vuetify: new Vuetify({
            theme: {
                themes: {
                    dark: {
                        primary: '#9A1414',
                        accent: '#9F3333',
                        secondary: '#393636'
                    },
                    light: {
                        primary: '#9A1414',
                        accent: '#9F3333',
                        secondary: '#B9B3B3'
                    }
                }
            }
        }),
        data: () => ({
            projectsPage: 1,
            navigationDrawer: false,
            loginForm: {},
            clickedLogin: false,
            clickedLogout: false,
            clickedRegister: false,
            clickedUpdateProject: false,
            clickedSubscribe: false,
            clickedUnsubscribe: false,
            clickedUpdateBoard: false,
            clickedUpdatePost: false,
            projectCreateFormIsActivated: false,
            projectCreateForm: {},
            registrationFormIsActivated: false,
            registrationForm: {},
            projectUpdateFormIsActivated: false,
            currentProjectData: {},
            newProjectData: {},
            plans: [{ name: "Plus", price: 1 }, { name: "Pro", price: 4 }],
            selectedPlan: "",
            unsubrsciptionFormIsActivated: false,
            nextPayment: new Date(),
            dataFetched: false,
            thisProjectIsLoaded: false,
            newBoardForm: {},
            newBoardFormIsActivate: false,
            currentBoardData: {},
            newBoardData: {},
            updateBoardFormIsActivate: false,
            showAllProjectMembers: false,
            newPostFormIsActivated: false,
            newPostForm: {},
            updatePostFormIsActivated: false,
            currentPostData: {},
            newPostData: {}
        }),
        computed: {
            ...Vuex.mapGetters('authentication', ['getAuthenticationStatus', 'getUser']),
            ...Vuex.mapGetters('shared', ['allUsernames']),
            ...Vuex.mapGetters('project', ['allProjects', 'projectsAreFetched', 'addingProject']),
            ...Vuex.mapGetters('post', ['allPosts']),
            ...Vuex.mapGetters('board', ['thisProject', 'allBoards']),
            // homepage
            cardCols() {
                switch (this.$vuetify.breakpoint.name) {
                    case 'xs': return 6
                    case 'sm': return 4
                    case 'md': return 4
                    case 'lg': return 3
                    case 'xl': return 3
                    default: return 3
                }
            },
            projectNameLimit() {
                switch (this.$vuetify.breakpoint.name) {
                    case 'xs': return 16
                    case 'sm': return 16
                    case 'md': return 16
                    case 'lg': return 16
                    case 'xl': return 16
                    default: return 16
                }
            },
            projectPerPage() {
                switch (this.$vuetify.breakpoint.name) {
                    case 'xs': return 2
                    case 'sm': return 3
                    case 'md': return 3
                    case 'lg': return 4
                    case 'xl': return 4
                    default: return 4
                }
            },
            projectMemberLimit() {
                switch (this.$vuetify.breakpoint.name) {
                    case 'xs': return 20
                    case 'sm': return 41
                    case 'md': return 41
                    case 'lg': return 41
                    case 'xl': return 41
                    default: return 41
                }
            },
            exceedProjectLimit() {
                switch (this.getUser.profile.plan) {
                    case 'Starter': return !(this.getUser.profile.projects < 1)
                    case 'Plus': return !(this.getUser.profile.projects < 3)
                    case 'Pro': return false
                    default: return true
                }
            },
            exceedBoardLimit() {
                switch (this.getUser.profile.plan) {
                    case 'Starter': return !(this.allBoards.length < 2)
                    case 'Plus': return !(this.allBoards.length < 3)
                    case 'Pro': return false
                    default: return true
                }
            }
        },
        methods: {
            ...Vuex.mapActions('authentication', ['login', 'logout', 'register', 'fecthUserData']),
            ...Vuex.mapActions('project', ['fetchProjects', 'addProject', 'removeProject']),
            ...Vuex.mapActions('board', ['fetchThisProject', 'fetchBoards', 'addBoard', 'removeBoard', 'moveBoard']),
            ...Vuex.mapActions('post', ['fetchPosts', 'addPost', 'toggleCompleteStatus', 'toggleUrgentStatus', 'movePost']),
            ...Vuex.mapActions('shared', ['fetchUsernames']),
            async loginAndReload(id, password) {
                await this.login({ id, password });
                location.reload()
            },
            async registerAndReload(username, email, password) {
                await this.register({ username, email, password });
                location.reload()
            },
            defaultProfilePicture(event) {
                event.target.src = "https://storage.googleapis.com/kwanjai-a3803.appspot.com/anonymous.png"
            },
            activeProjectUpdater(projectId, thisProject) {
                this.projectUpdateFormIsActivated = true
                if (!thisProject) {
                    thisProject = this.allProjects.find((project) => { return project.id == projectId })
                }
                this.currentProjectData = { ...thisProject }
                this.newProjectData = { ...this.currentProjectData }
            },
            async updateProject() {
                const nameIsEdited = this.currentProjectData.name !== this.newProjectData.name
                const memberIsEdited = JSON.stringify(this.currentProjectData.members.sort()) !== JSON.stringify(this.newProjectData.members.sort())
                const projectIsEdited = nameIsEdited || memberIsEdited
                if (projectIsEdited) {
                    try {
                        await axios.patch('/api/project/update',
                            this.newProjectData,
                            { headers: await requestHeader() }
                        )
                        if (!JSON.parse(`$gin{ .projectId }`)) {
                            this.$store.dispatch('project/updateProject', { ...this.newProjectData })
                        }
                        await this.fetchThisProject()
                        document.title = `Project - ${this.thisProject.name}`
                    } catch (error) {
                        errorResponseAlert(error)
                        location.reload()
                    }
                }
                this.projectUpdateFormIsActivated = false
                this.clickedUpdateProject = false
            },
            subscribe() {
                const price = this.plans.find(element => { return element.name == this.selectedPlan }).price * 100
                const self = this
                OmiseCard.open({
                    amount: price,
                    currency: "USD",
                    defaultPaymentMethod: "credit_card",
                    async onCreateTokenSuccess(nonce) {
                        self.clickedSubscribe = true
                        try {
                            await axios.post('/api/user/pay', { token: nonce, price }, { headers: await requestHeader() })
                            location.reload()
                        } catch (error) {
                            errorResponseAlert(error)
                            location.reload()
                        }
                    }
                })
            },
            async unsubscribe() {
                this.clickedUnsubscribe = true
                try {
                    await axios.post('/api/user/unsubscribe', null, { headers: await requestHeader() })
                    location.reload()
                } catch (error) {
                    errorResponseAlert(error)
                    location.reload()
                }
            },
            // project page
            activeBoardUpdater(boardId) {
                this.updateBoardFormIsActivate = true
                const thisBoard = this.allBoards.find((board) => { return board.id == boardId })
                this.currentBoardData = { ...thisBoard }
                this.newBoardData = { ...this.currentBoardData }
            },
            async updateBoard() {
                const nameIsEdited = this.currentBoardData.name !== this.newBoardData.name
                if (nameIsEdited) {
                    try {
                        await axios.patch('/api/board/update',
                            this.newBoardData,
                            { headers: await requestHeader() }
                        )
                        this.$store.dispatch('board/updateBoard', { ...this.newBoardData })
                    } catch (error) {
                        errorResponseAlert(error)
                        location.reload()
                    }
                }
                this.updateBoardFormIsActivate = false
                this.clickedUpdateBoard = false
            },
            activePostUpdater(postId) {
                const thisPost = this.allPosts.find((board) => { return board.id == postId })
                this.currentPostData = { ...thisPost }
                this.currentPostData.due_date = this.currentPostData.due_date.substring(0, 10)
                this.newPostData = { ...this.currentPostData }
                this.updatePostFormIsActivated = true
            },
            async updatePost() {
                this.clickedUpdatePost = true
                const titleIsEdited = this.currentPostData.title !== this.newPostData.title
                const contentIsEdited = this.currentPostData.content !== this.newPostData.content
                const dueDateIsEdited = this.currentPostData.due_date !== this.newPostData.due_date
                const peopleIsEdited = JSON.stringify(this.currentPostData.people.sort()) !== JSON.stringify(this.newPostData.people.sort())
                if (titleIsEdited || contentIsEdited || dueDateIsEdited || peopleIsEdited) {
                    try {
                        let copied = { ...this.newPostData }
                        copied.due_date = new Date(this.newPostData.due_date + ' 00:00:00').toISOString()
                        await axios.patch('/api/post/update',
                            copied,
                            { headers: await requestHeader() }
                        )
                        this.$store.dispatch('post/updatePost', this.newPostData)
                    } catch (error) {
                        errorResponseAlert(error)
                        location.reload()
                    }
                }
                this.updatePostFormIsActivated = false
                this.clickedUpdatePost = false
            }
        },
        async created() {
            const location = window.location.pathname
            if (this.getAuthenticationStatus) {
                await this.fecthUserData()
                this.nextPayment.setDate(this.getUser.profile.date_of_subscription)
                this.nextPayment.setMonth(this.nextPayment.getMonth() + 1)
                await this.fetchProjects()
                await this.fetchUsernames()
            }
            this.dataFetched = true
            if (location.startsWith('/project/')) {
                await this.fetchThisProject()
                document.title = `Project - ${this.thisProject.name}`
                await this.fetchBoards()
                await this.fetchPosts()
                this.thisProjectIsLoaded = true
            }
        },
        mounted() {
        },
    })
</script>
$gin{end}